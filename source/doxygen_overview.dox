# DeskUp  Internal Architecture and Flow

DeskUp is organized into three main layers:

- **Frontend**: high-level orchestration of window and workspace operations.
- **Core**: backend initialization and management logic.
- **Backend**: platform-specific implementations for Windows

This page mirrors the GitHub README but adds Doxygen cross-references for symbols.

---

## 1. Initialization  Choosing and bootstrapping a backend

When DeskUp starts, the application calls **\ref DU_Init**
(declared in [`source/desk_up_backend_interface_backend/window_core.h`](./desk_up_backend_interface_backend/window_core.h)
and implemented in [`source/desk_up_backend_interface_backend/window_core.cc`](./desk_up_backend_interface_backend/window_core.cc)).

\ref DU_Init performs three key actions:

1. Iterates through a list of available **backend bootstraps** (currently only Windows).
   - The Windows backend defines its bootstrap (`winWindowDevice`) in
     [`source/desk_up_backend_interface_backend/window_backends/desk_up_win/desk_up_win.h`](./desk_up_backend_interface_backend/window_backends/desk_up_win/desk_up_win.h).

2. For each backend, it checks availability via
   `DeskUpWindowBootStrap::isAvailable()`  **\ref WIN_isAvailable**.

3. Once it finds a working backend, it:
   - Creates the device with `DeskUpWindowBootStrap::createDevice()`  **\ref WIN_CreateDevice**.
   - Retrieves the base folder with `DeskUpWindowDevice::getDeskUpPath()`  **\ref WIN_getDeskUpPath**.
   - Sets the global variables:
     - **DESKUPDIR**  base workspace directory.
     - **current_window_backend**  active backend device.

If initialization succeeds, \ref DU_Init logs the connected backend and returns `1`.
If none is available, it returns `0`.

---

## 2. High-level operations  DeskUpWindow faade

The structure \ref DeskUpWindow is defined in
[`source/desk_up_backend_interface/desk_up_backend_interface.h`](./desk_up_backend_interface/desk_up_backend_interface.h)
and implemented in
[`source/desk_up_backend_interface/desk_up_backend_interface.cc`](./desk_up_backend_interface/desk_up_backend_interface.cc).

It acts as the **frontend faade**, coordinating workspace-level operations with the backend.

### `DeskUpWindow::saveAllWindowsLocal(std::string workspaceName)`
1. Builds `<DESKUPDIR>/<workspaceName>` using the global path set by \ref DU_Init.
2. Ensures the directory exists (via `std::filesystem`).
3. Requests the active backend to enumerate all windows through
   `current_window_backend->getAllWindows(current_window_backend.get())`.
4. Receives a list of \ref windowDesc records from the backend.
5. Saves each record to a text file using \ref windowDesc::saveTo.

If any backend or I/O operation fails, the function catches the exception and returns `0`, avoiding crashes.

---

## 3. Window representation  The `windowDesc` structure

Defined in [`source/desk_up_backend_interface_backend/window_desc/window_desc.h`](./desk_up_backend_interface_backend/window_desc/window_desc.h)
and implemented in [`source/desk_up_backend_interface_backend/window_desc/window_desc.cc`](./desk_up_backend_interface_backend/window_desc/window_desc.cc).

Each \ref windowDesc instance represents a window in an abstract, cross-platform way.

**Fields:**
- `name`  window or executable name.
- `x`, `y`, `w`, `h`  position and size.
- `pathToExec`  absolute path to the owning executable.

**Behavior:**
- \ref windowDesc::saveTo writes the above fields as plain text.
- Returns `0` if the path is empty or cannot be opened.
- `operator!()` is a validity check (true if geometry is all zero).

---

## 4. Backend implementation  Windows

The Windows backend lives in
[`source/desk_up_backend_interface_backend/window_backends/desk_up_win/desk_up_win.h`](./desk_up_backend_interface_backend/window_backends/desk_up_win/desk_up_win.h)
and [`source/desk_up_backend_interface_backend/window_backends/desk_up_win/desk_up_win.cc`](./desk_up_backend_interface_backend/window_backends/desk_up_win/desk_up_win.cc).

It defines:
```cpp
DeskUpWindowBootStrap winWindowDevice = {
    "win",
    WIN_CreateDevice,
    WIN_isAvailable
};
```

### Backend creation
- \ref WIN_CreateDevice builds a new \ref DeskUpWindowDevice and wires function pointers for:
  - `getAllWindows`
  - `getWindowHeight`, `getWindowWidth`, `getWindowXPos`, `getWindowYPos`
  - `getDeskUpPath`

### Enumerating windows
\ref WIN_getAllWindows calls `EnumDesktopWindows`, which triggers a callback to:
1. Skip invisible or zero-sized windows.
2. Populate a \ref windowDesc using:
   - \ref WIN_getWindowXPos, \ref WIN_getWindowYPos, \ref WIN_getWindowWidth, \ref WIN_getWindowHeight  `GetWindowInfo`.
   - \ref WIN_getPathFromWindow  process path via
     `GetWindowThreadProcessId`  `OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION)`  `QueryFullProcessImageNameW`.
3. Append each valid record to a `std::vector<windowDesc>`.

### Workspace path resolution
\ref WIN_getDeskUpPath determines the folder:
- Uses `SHGetKnownFolderPath(FOLDERID_RoamingAppData)` when available.
- Falls back to `%APPDATA%` or the executable directory.
- Ensures a `DeskUp/` folder exists.

---

## 5. Flow summary

```text
DU_Init()
  |--> winWindowDevice.isAvailable() -> WIN_isAvailable()
  |--> winWindowDevice.createDevice() -> WIN_CreateDevice()
  |--> dev.getDeskUpPath() -> WIN_getDeskUpPath()
  \--> sets DESKUPDIR and current_window_backend

DeskUpWindow::saveAllWindowsLocal("WorkspaceName")
  |--> builds <DESKUPDIR>\WorkspaceName
  |--> current_window_backend->getAllWindows(...) -> WIN_getAllWindows()
  |     |--> EnumDesktopWindows -> WIN_createAndSaveWindow()
  |     \--> fills std::vector<windowDesc>
  |--> iterates vector
  |     \--> windowDesc::saveTo(<workspace path>)
  \--> returns success (1) or failure (0)
```

---

## 6. File map (as in the repository)

- `source/desk_up_backend_interface/desk_up_backend_interface.h` / `.cc`  frontend orchestration (uses backend).
- `source/desk_up_backend_interface_backend/window_core.h` / `.cc`  backend initialization (DU_Init) and global state.
- `source/desk_up_backend_interface_backend/window_backends/desk_up_win/desk_up_win.h` / `.cc`  Windows-specific backend.
- `source/desk_up_backend_interface_backend/window_desc/window_desc.h` / `.cc`  window record + persistence.
- `source/desk_up_backend_interface_backend/backend_utils.cc`  backend helpers.
- `source/desk_up_backend_interface_backend/desk_up_backend_interface_device.h`, `desk_up_backend_interface_bootstrap.h`  device/bootstrap interfaces.
- `source/desk_up/`, `source/desk_up/`  additional higher-level modules.
- `source/main.cc`  entry point.

---

## 7. Extensibility

The folder
[`source/desk_up_backend_interface_backend/window_backends/desk_up_x11`](./desk_up_backend_interface_backend/window_backends/desk_up_x11)
scaffolds a future **X11/Linux backend**. Adding a new backend requires a new \ref DeskUpWindowBootStrap with:
- `isAvailable()`  to detect platform support.
- `createDevice()`  to provide the correct function pointers.

*/